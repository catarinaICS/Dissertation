%!TEX root = ../dissertation.tex

\chapter{Implementation}
\label{chapter:implementation}

The application developed follows a Model-View-Controller architecture.

This architecture is composed of three elements \cite{krasner1988description}:
\begin{itemize}
\item The Model, which captures and stores information about the application domain;
\item The View, which generates output based on the model state;
\item The Controller, which provides interaction between the Views and the Model. It is able to modify the Model and update the corresponding View.
\end{itemize}

The standard interaction cycle in this architecture is the following \cite{krasner1988description,reenskaug2009dci}:
\begin{itemize}
\item A user interacting with the application sends a request to the Controller.

\item The Controller communicates with the Model to apply the desired changes.

\item The Model is updated.

\item The Controller notifies the corresponding View so it can be updated with the new version of the Model.
\end{itemize}

The next sections will describe the solution implementation based on these three elements.


\section{Model}
\label{section:model}
The Model of the implemented system is based on the Domain Model presented in chapter \ref{chapter:domainModel}, but a few modifications were made to facilitate programming.

\subsection{Annotations}
\label{subsection:modelAnnotations}
As seen in Chapter \ref{chapter:architecture}, the Document is one of the most important entities, because it aggregates all the annotations created over the text and all the Software Architectures concepts elicited.

Similarly to what is shown in figure \ref{figure:documentAnnotation} of chapter \ref{chapter:architecture}, in the implemented model, the Document entity is connected to the Annotation. However, an annotation is created by an user authenticated in the system, and this information is also present in the domain, as shown in figure \ref{figure:modelDocUserAnnot}. The ``User'' entity saves users registered in the system. When a user creates an annotation, it is associated to him.

\begin{figure}
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}

\begin{tikzpicture}
\begin{class}[text width=3cm ]{Document}{0,0}
	\attribute { title : String }
	\attribute { url : String }
	\attribute { content : String }
\end{class}

\begin{class}[text width=3.5cm ]{Annotation}{-2,-5}
	\attribute { annotation : String }
	\attribute { tag : String }
\end{class}

\begin{class}[text width=3.5cm ]{User}{-6,0}
	\attribute { username : String }
	\attribute { password : String }
	\attribute { firstName : String }
	\attribute { lastName : String}
	\attribute { type : String}
\end{class}
\association {Document}{document}{1}{Annotation}{annotations}{0..*}
\association {User}{owner}{1}{Annotation}{}{0..*}

\end{tikzpicture}
\caption{Document, Annotations and Users in the implemented Model}
\label{figure:modelDocUserAnnot}
\end{figure} 
 
\subsection{Scenarios}
\label{subsection:modelScenarios}
Figure \ref{figure:modelScenarios} shows how scenarios are represented in the implemented model. This diagram is similar to what is shown in figure \ref{figure:abstractDomainModel}, with a small difference regarding the Scenario Quality Requirement and Tactics. 

The diagram in section \ref{section:model} shows an association between Tactic and Quality Requirement, in the sense that there are a set of tactics used to achieve that quality requirement. 

Regarding the model implemented, a quality requirement instance is associated with the scenario upon its creation, but tactics, which are added to the scenario afterwards, are only associated to that scenario and nothing else. The Quality Requirement and the Tactics are only related in the sense that the quality requirement associated upon scenario creation will define which tactics can be added to the scenario. This will be described further.

The Scenario is a main concept of the domain, and therefore is connected to the Document. The ``identifier'' parameter in the entities stores the name of the concept that corresponds to that entity, and often corresponds to the name of the entity itself. For example, the identifier in all instances of Scenario is ``Scenario'' and the identifier in all instances of ``SrcOfStimulus'' is ``Source Of Stimulus''. This was done to facilitate programming. The ``name'' attribute in the Scenario gives it an identification other than just the quality attribute, and the ``text'' attribute corresponds to the description text that can be added to the templates.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}

\begin{tikzpicture}
\begin{class}[text width=3cm ]{Document}{9,-2.5}
	\attribute { title : String }
	\attribute { url : String }
	\attribute { content : String }
\end{class}

\begin{class}[text width=3cm ]{Scenario}{9,-7.5}
	\attribute { name : String}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{QualityRequirement}{9,-13.5}
	\attribute { name : String}
\end{class}

\begin{class}[text width=3cm ]{SrcOfStimulus}{0,-1.5}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}	

\begin{class}[text width=3cm ]{Stimulus}{0,-3.5}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Artifact}{0,-5.5}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Environment}{0,-7.5}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Response}{0,-9.5}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{ResponseMeasure}{0,-11.5}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Tactic}{0,-13.5}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\association {Scenario}{}{1}{SrcOfStimulus}{}{0..1}
\association {Scenario}{}{1}{Stimulus}{}{0..1}
\association {Scenario}{}{1}{Artifact}{}{0..1}
\association {Scenario}{}{1}{Environment}{}{0..1}
\association {Scenario}{}{1}{Response}{}{0..1}
\association {Scenario}{}{1}{ResponseMeasure}{}{0..1}
\association {Scenario}{}{1}{Tactic}{}{*}
\association {Scenario}{}{*}{Document}{}{0..1}
\association {Scenario}{}{*}{QualityRequirement}{}{0..1}

\end{tikzpicture}
\caption{Scenario Representation in the implemented Model}
\label{figure:modelScenarios}
\end{figure}

To facilitate programming, all Scenario elements are a subclass of a ``ScenarioElement'' class, as seen in the example in Figure \ref{figure:modelScenarioElement}. This class contains a series of methods that are common to all the Scenario Elements. A few of those methods are shown in the figure. However, this class is not associated with the Scenario entity. Its purpose is only to facilitate programming by aggregating common methods. 

\begin{figure}
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}

\begin{tikzpicture}

\begin{class}[text width=4cm ]{ScenarioElement}{0,0}
	\attribute { identifier : String }
	\attribute { text : String }
	\operation { getIdentifier() : String }
	\operation { getText() : String}
\end{class}

\begin{class}[text width=3cm ]{SrcOfStimulus}{-2.1,-4}
	\inherit{ScenarioElement}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\draw [umlcd style] (0,-4.7) node {[...]};

\begin{class}[text width=3.5cm ]{ResponseMeasure}{2.2,-4}
	\inherit{ScenarioElement}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}		
	
\end{tikzpicture}
\caption{The ScenarioElement entity}
\label{figure:modelScenarioElement}
\end{figure}

All domain entities have associated annotations, as it was mentioned previously in Section \ref{section:annotation}. Figure \ref{figure:modelScenariosAnnotations} shows how scenarios and their elements are related with the annotations in the implemented model. This diagram is similar to the one in figure \ref{figure:annotationConcept} and shows the association between the Scenario and ScenarioElement with the Annotation.

\begin{figure}
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}

\begin{tikzpicture}
\begin{class}[text width=3.5cm ]{Annotation}{0,0}
	\attribute { annotation : String }
	\attribute { tag : String }
\end{class}
\begin{class}[text width=3cm ]{ScenarioElement}{-2,-4}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Scenario}{2,-4}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}	
\association {Scenario}{}{0..1}{Annotation}{}{*}
\association {ScenarioElement}{}{0..1}{Annotation}{}{*}
\end{tikzpicture}
\caption{Scenarios and Scenario Elements and their relation with Annotations in the implemented model}
\label{figure:modelScenariosAnnotations}
\end{figure}

\subsection{Views}
\label{subsection:modelViews}

The abstract domain model presented in Figure \ref{figure:abstractDomainModel} of Chapter \ref{chapter:domainModel} shows how a View is related to the Viewtype, the Styles and the elements. A View is considered a main concept in the sense that it has its own dedicated template, and so does the Element.

The implemented model supports the inclusion of Module viewtype Views and their respective Modules and relations. Figure \ref{figure:modelViewsAndModules} shows how the model is implemented. The viewtype and style of a view are attributes of the View entity, and are used to guarantee that the correct elements are added to the view. The ``name'' attribute of the View corresponds to a name given by the user when creating the View, and should help its identification, and, as for the Scenario and its elements, the ``text'' attribute corresponds to text that users can add to the template.

Views and Modules are created, as mentioned before, by associating annotations to them, hence the connection between these entities and the Annotation shown in figure \ref{figure:modelViewsModulesAnnotations}. Upon creation, they are also associated with the corresponding Document.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}
\begin{class}[text width=3.5cm ]{View}{0,0}
	\attribute { name : String }
	\attribute { viewtype : String }
	\attribute { style : String }
	\attribute { text : String }
\end{class}
\begin{class}[text width=3cm ]{Module}{-3,-4}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Document}{3,-4}
	\attribute { title : String }
	\attribute { url : String }
	\attribute { content : String }
\end{class}	
\association {View}{}{*}{Document}{}{0..1}
\association {Module}{}{*}{Document}{}{0..1}
\association {Module}{}{*}{View}{}{*}

\end{tikzpicture}

\caption{View and Module in the implemented Model}
\label{figure:modelViewsAndModules}
\end{figure}

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}
\begin{class}[text width=3.5cm ]{View}{0,0}
	\attribute { name : String }
	\attribute { viewtype : String }
	\attribute { style : String }
	\attribute { text : String }
\end{class}
\begin{class}[text width=3cm ]{Module}{-3,-4}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Annotation}{3,-4}
	\attribute { annotation : String }
	\attribute { tag : String }

\end{class}	
\association {View}{}{0..1}{Annotation}{}{*}
\association {Module}{}{0..1}{Annotation}{}{*}
\association {Module}{}{*}{View}{}{*}

\end{tikzpicture}

\caption{Views and Modules relationship with Annotations in the implemented Model}
\label{figure:modelViewsModulesAnnotations}
\end{figure}

\subsection{Modules}
\label{subsection:modules}

The Modules are the elements of the Module Viewtype Views. As seen in Figure \ref{figure:modelViewsAndModules}, and similarly to the Scenario and the View entities, it has a ``name'' attribute, which provides identification and also gives an idea on what are the Module functions, and a ``text'' attribute, which corresponds to text added to the template.

As seen in the abstract domain model present in Figure \ref{figure:abstractDomainModel} of Chapter \ref{chapter:domainModel}, the elements of a view have a certain type of relationship with each others. There are eight types of relationships between Modules \cite{clements2003documenting}:
\begin{itemize}
\item \textit{Is-Part-Of} - a Module can be part of a parent Module; 
\item \textit{Uses} - a Module depends on the correct functioning of other Modules to satisfy its own requirements;
\item \textit{Is-A} - a relation of generalization, in which a Module is a generalization, or parent, of other modules; 
\item \textit{Crosscuts} - an Aspect Module, which implements a crosscutting concern of the system, is bound to a Module that is affected by that crosscutting concern;
\item \textit{One-To-One, One-To-Many, Many-to-Many} - logical associations between Data Entity Modules, similar to the UML associations;
\item \textit{Aggregation} - an aggregation relation;
\end{itemize}

Although the abstract domain model in Figure \ref{figure:abstractDomainModel} contains an entity ``Relation'' to represent how the view elements are connected, in the case of the Modules, these relations have no other information than the Modules connected. Therefore, in the implemented model, there are no entities representing the relationships between modules. Instead, there were defined different associations of the Module entity to itself, in order to represent the different relations.

\subsubsection{Is-Part-Of}

The \textit{Is-Part-Of} relation specifies that a Module can be a Sub-Module of one and only one other Module. Figure \ref{figure:modelIsPartOfRelation} shows how this relation was implemented.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small parent};
\draw [umlcd style] (0.5,-2.2) node {\small 0..1};
\draw [umlcd style] (2.060,-0.5) node {\small child};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Is-Part-Of relation between Modules in the implemented model}
\label{figure:modelIsPartOfRelation}
\end{figure}

\subsubsection{Uses}

The \textit{Uses} relation specifies that a Module can depend on the correct functioning of one or more Modules, and one or more Modules can depend on the correct functioning of this Module. Figure \ref{figure:modelUsesRelation} shows how this relation was implemented.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small uses};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.2,-0.5) node {\small usedBy};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Uses relation between Modules in the implemented model}

\label{figure:modelUsesRelation}
\end{figure}

\subsubsection{Is-A}

The \textit{Is-A} relation specifies that a Module can be a specialization of a more general Module. Figure \ref{figure:modelIsARelation} shows how this relation was implemented. There are no restrictions on multiple inheritance in this relation, so a Module can be a specialization of more than one Module. 

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small isA};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.6,-0.5) node {\small superModule};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Uses relation between Modules in the implemented model}
\label{figure:modelIsARelation}
\end{figure}

\subsubsection{Crosscuts}

The \textit{Crosscut} relation specifies that an Aspects Module, which implements a crosscutting concern of the system, can be associated with Modules that are affected with that crosscutting concern. Figure \ref{figure:modelCrosscutsRelation} shows how this relation was implemented in the model.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small crosscuts};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.7,-0.5) node {\small crosscuttedBy};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Uses relation between Modules in the implemented model}
\label{figure:modelCrosscutsRelation}
\end{figure}

\subsubsection{One-To-One, One-To-Many, Many-to-Many}

The \textit{One-To-One, One-To-Many} and \textit{Many-to-Many} relation specify logical associations between Data Entity Modules, similar to UML associations. Figures \ref{figure:modelOneToOneRelation}, \ref{figure:modelOneToManyRelation} and \ref{figure:modelManyToManyRelation} show how these relations were implemented in the model.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small oneToOne};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.7,-0.5) node {\small oneRelation};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{One-To-One relation between Modules in the implemented model}
\label{figure:modelOneToOneRelation}
\end{figure}

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small oneToMany};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (3.15,-0.5) node {\small oneToManyRelations};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{One-To-Many relation between Modules in the implemented model}
\label{figure:modelOneToManyRelation}
\end{figure}

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small manyToMany};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (3.25,-0.5) node {\small manyToManyRelations};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Many-To-Many relation between Modules in the implemented model}
\label{figure:modelManyToManyRelation}
\end{figure}

\textbf{To note:} the '*' cardinality in these relations means that a Module can have several relations of this type in a Data Model Style view. For example, if a Module instance with name ``Department'' has a ``One-To-Many'' relation with Modules ``Employee'' and ``Room'', it means that a visual representation of these Modules would be the one in figure \ref{figure:modelOneToManyExample}.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=2.5cm ]{Department}{0,0}
	\attribute {}
\end{class}

\begin{class}[text width=2cm ]{Room}{-2.5,-3}
	\attribute {}
\end{class}

\begin{class}[text width=2cm ]{Employee}{2.5,-3}
	\attribute {}
\end{class}

\association{Department}{}{1}{Room}{}{*}
\association{Department}{}{1}{Employee}{}{*}
\end{tikzpicture}
\caption{Example of the One-To-Many relation between Modules}
\label{figure:modelOneToManyExample}
\end{figure}

\subsubsection{Aggregation}

The \textit{Aggregation} relation specifies that a Module can be an aggregator of other Modules. Figure \ref{figure:modelAggregationRelation} shows how this relation is implemented in the system.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small aggregator};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.45,-0.5) node {\small aggregated};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Aggregation relation between Modules in the implemented model}
\label{figure:modelAggregationRelation}
\end{figure}

\section{Controllers}

\subsection{Annotation Controller}
The Annotation Controller provides a way to manage the annotations added to a document. It communicates with the Domain Model to create, remove or update Annotations. The particularity of this controller is that it provides a REST API, which is used to retrieve a JSON representation of the annotations stored in the model and display it along with the document text. 
The endpoints provided by this controller are described in Table \ref{table:endpoints}.
\begin{table}[h]
\begin{tabular}{ | l | l | l |p{7.7cm}|}
    \hline
    Name & Method & Endpoint & Description \\ \hline
    Index & GET & ../store/annotations & \parbox[t]{8cm}{Returns the set of annotations associated with a \\specific document }\\ \hline
    Read & GET & ../store/annotations/id & Returns the annotation with the specific id \\ \hline
    Create & POST & ../store/annotations & \parbox[t]{8cm}{Creates a new annotation, stores it in the model, \\and redirects to the Read endpoint} \\ \hline
    Update & PUT & ../store/annotations/id & \parbox[t]{8cm}{Updates the annotation with the given id and \\redirects to the Read endpoint} \\ \hline
    Delete & DELETE & ../store/annotations/id & \parbox[t]{8cm}{Removes the annotation with the given id. The \\response is a HTTP/1.0 204 NO CONTENT.} \\ \hline
  \end{tabular}
  \caption{REST API provided by the Annotation Controller}
  \label{table:endpoints}
\end{table}


\subsection{Document Controller}
The Document Controller handles the requests to view, add or remove a document from the system.

\subsection{Scenario Controller}
The Scenario Controller handles the construction of templates for Scenarios. All requests to create a new scenario, link document annotations to a specific scenario or delete a scenario are handled in this controller.
