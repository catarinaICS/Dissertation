%!TEX root = ../dissertation.tex

\chapter{Implementation}
\label{chapter:implementation}

The application developed follows a Model-View-Controller architecture.

This architecture is composed of three elements \cite{krasner1988description}:
\begin{itemize}
\item The Model, which captures and stores information about the application domain;
\item The View, which generates output based on the model state;
\item The Controller, which provides interaction between the Views and the Model. It is able to modify the Model and update the corresponding View.
\end{itemize}

The standard interaction cycle in this architecture is the following \cite{krasner1988description,reenskaug2009dci}:
\begin{itemize}
\item A user interacting with the application sends a request to the Controller.

\item The Controller communicates with the Model to apply the desired changes.

\item The Model is updated.

\item The Controller notifies the corresponding View so it can be updated with the new version of the Model.
\end{itemize}

The next sections will describe the solution implementation based on these three elements.


\section{Model}
\label{section:model}
The Model of the implemented system is based on the Domain Model presented in chapter \ref{chapter:domainModel}, but a few modifications were made to facilitate programming.

The developed application uses the F\'{e}nix Framework, which allows the creation of a transactional and persistent domain model for applications \cite{cachopo2006combining,cachopo2007development}. The domain model is specified in the Domain Modeling Language, which is a domain-specific language created for this framework. The framework completely hides the database from the programmer, who can focus on the application development in Java. 

\subsection{Annotations}
\label{subsection:modelAnnotations}
As seen in Chapter \ref{chapter:architecture}, the Document is one of the most important entities, because it aggregates all the annotations created over the text and all the Software Architectures concepts elicited.

Similarly to what is shown in Figure \ref{figure:documentAnnotationConcepts} of Chapter \ref{chapter:architecture}, in the implemented model, the Document entity is connected to the Annotation. However, an annotation is created by an user authenticated in the system, and this information is also present in the domain, as shown in figure \ref{figure:modelDocUserAnnot}. The ``User'' entity saves users registered in the system. When a user creates an annotation, it is associated to him.

\begin{figure}
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}

\begin{tikzpicture}
\tikzstyle{every node}=[font=\footnotesize]
\begin{class}[text width=3cm ]{Document}{0,0}
	\attribute { title : String }
	\attribute { url : String }
	\attribute { content : String }
\end{class}

\begin{class}[text width=3.5cm ]{Annotation}{-2,-5}
	\attribute { annotation : String }
	\attribute { tag : String }
\end{class}

\begin{class}[text width=3.5cm ]{User}{-6,0}
	\attribute { username : String }
	\attribute { password : String }
	\attribute { firstName : String }
	\attribute { lastName : String}
	\attribute { type : String}
\end{class}
\association {Document}{document}{1}{Annotation}{annotations}{0..*}
\association {User}{owner}{1}{Annotation}{}{0..*}

\end{tikzpicture}
\caption{Document, Annotations and Users in the implemented Model}
\label{figure:modelDocUserAnnot}
\end{figure} 
 
\subsection{Scenarios}
\label{subsection:modelScenarios}
The Scenario is a main concept of the domain, and therefore is connected to the Document, as seen in Figure \ref{figure:documentConcept}. 

Scenarios are represented in the implemented model in a very similar way to what is shown in Figure \ref{figure:abstractDomainModel}. However, there is a difference in the implemented model regarding how Quality Requirements and Tactics are represented.

In Figure \ref{figure:abstractDomainModel},  it is shown an association between Scenario and Quality Requirement, Scenario and Tactic and Tactic and Quality Requirement. The meaning of these associations is to represent what is explained in Section \ref{subsection:SAConceptsScenarios}: A Scenario has a Quality Requirement from a set of pre-existent ones, and a set of Tactics also from a set of existent ones, which are specific for the Quality Requirement.

However, in the implemented model, there are no pre-existent Tactics nor Quality Requirements. The existent Quality Requirements and their specific Tactics are specified in a Java class, which returns them as necessary. Figure \ref{figure:modelQRTactics} shows the Scenario, Tactic and Quality Requirement entities, and how they are related in the implemented model.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}

\begin{tikzpicture}
\tikzstyle{every node}=[font=\footnotesize]
\begin{class}[text width=3cm ]{Scenario}{0,0}
	\attribute { name : String}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{QualityRequirement}{-5,0}
	\attribute { name : String}
\end{class}

\begin{class}[text width=3cm ]{Tactic}{-5,-2}
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\association {Scenario}{}{1}{Tactic}{}{*}
\association {Scenario}{}{0..1}{QualityRequirement}{}{0..1}

\end{tikzpicture}
\caption{Quality Requirements and Tactics detail in the implemented Model}
\label{figure:modelQRTactics}
\end{figure}

To create a Scenario, it is necessary to select a Quality Requirement from a list, which is retrieved from the class mentioned. When the Scenario is created, a new Quality Requirement is also created, with the selected one stored into the ``name'' attribute, and associated with that Scenario. Inside the Scenario template, Tactics can be added. To add a tactic it is necessary to select it from a list of specific tactics for the quality requirement. That list is, again, retrieved from the class mentioned before. When a specific tactic is selected, a new Tactic is created in the model with the specific tactic name stored in the ``identifier'' attribute. Given these implementation details, there was no need to create the association between Tactic and QualityRequirement nor to have a Quality Requirement associated with many Scenarios.

To facilitate programming, all Scenario elements are a subclass of a ``ScenarioElement'' class, as seen in the example in Figure \ref{figure:modelScenarioElement}. This superclass aggregates all the methods common to the Scenario elements, making it easier to perform actions such as updating the text, associating annotations or presenting the elements in a view. A few of those methods are shown in the figure. However, this class is not associated with the Scenario entity. Its purpose is only to facilitate programming by aggregating common methods. 

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}

\begin{tikzpicture}
\tikzstyle{every node}=[font=\footnotesize]
\begin{class}[text width=3cm ]{ScenarioElement}{0,0}
	\attribute { identifier : String }
	\attribute { text : String }
	\operation { getIdentifier() : String }
	\operation { getText() : String}
	\operation { (...)}
\end{class}

\begin{class}[text width=2.5cm ]{SrcOfStimulus}{-2.1,-4}
	\inherit{ScenarioElement}
	\attribute{}
\end{class}

\draw [umlcd style] (0,-4.3) node {[...]};

\begin{class}[text width=3cm ]{ResponseMeasure}{2.2,-4}
	\inherit{ScenarioElement}
	\attribute{}
\end{class}		
	
\end{tikzpicture}
\caption{The ScenarioElement entity}
\label{figure:modelScenarioElement}
\end{figure}

The ``identifier'' parameter of the entities, seen in  Figures \ref{figure:modelQRTactics} and \ref{figure:modelScenarioElement} stores the name of the concept that corresponds to that entity, and often corresponds to the name of the entity itself. For example, the identifier in all instances of Scenario is ``Scenario'' and the identifier in all instances of ``SrcOfStimulus'' is ``Source Of Stimulus''. This was done to facilitate certain programming issues such as getting the concept name from a ``ScenarioElement'' instance. The ``name'' attribute in the Scenario gives it an identification other than just the quality attribute, and the ``text'' attribute in the Scenario and ScenarioElement corresponds to the description text that can be added to the templates.

All domain entities have associated annotations, as it was mentioned previously in Section \ref{section:annotation}. The implemented model is similar to what is shown in Figure \ref{figure:documentAnnotationConcepts}, with the Scenario and ScenarioElement entities being associated with the Annotation.

\subsection{Views}
\label{subsection:modelViews}

The abstract domain model presented in Figure \ref{figure:abstractDomainModel} of Chapter \ref{chapter:domainModel} shows how a View is related to the Viewtype, the Styles and the elements. A View is considered a main concept in the sense that it has its own dedicated template, and so does the Element.

The implemented model supports the inclusion of Module viewtype Views and their respective Modules and relations. Figure \ref{figure:modelViewsAndModules} shows how the model is implemented. The viewtype and style of a view are attributes of the View entity, and are used to guarantee that the correct elements are added to the view. The ``name'' attribute of the View corresponds to a name given by the user when creating the View, and should help its identification, and, as for the Scenario and its elements, the ``text'' attribute corresponds to text that users can add to the template.

Views and Modules are created, as mentioned before, by associating annotations to them, hence the connection between these entities and the Annotation shown in figure \ref{figure:modelViewsModulesAnnotations}. Upon creation, they are also associated with the corresponding Document.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}
\begin{class}[text width=3.5cm ]{View}{0,0}
	\attribute { name : String }
	\attribute { viewtype : String }
	\attribute { style : String }
	\attribute { text : String }
\end{class}
\begin{class}[text width=3cm ]{Module}{-3,-4}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Document}{3,-4}
	\attribute { title : String }
	\attribute { url : String }
	\attribute { content : String }
\end{class}	
\association {View}{}{*}{Document}{}{0..1}
\association {Module}{}{*}{Document}{}{0..1}
\association {Module}{}{*}{View}{}{*}

\end{tikzpicture}

\caption{View and Module in the implemented Model}
\label{figure:modelViewsAndModules}
\end{figure}

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}
\begin{class}[text width=3.5cm ]{View}{0,0}
	\attribute { name : String }
	\attribute { viewtype : String }
	\attribute { style : String }
	\attribute { text : String }
\end{class}
\begin{class}[text width=3cm ]{Module}{-3,-4}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}

\begin{class}[text width=3cm ]{Annotation}{3,-4}
	\attribute { annotation : String }
	\attribute { tag : String }

\end{class}	
\association {View}{}{0..1}{Annotation}{}{*}
\association {Module}{}{0..1}{Annotation}{}{*}
\association {Module}{}{*}{View}{}{*}

\end{tikzpicture}

\caption{Views and Modules relationship with Annotations in the implemented Model}
\label{figure:modelViewsModulesAnnotations}
\end{figure}

\subsection{Modules}
\label{subsection:modules}

The Modules are the elements of the Module Viewtype Views. As seen in Figure \ref{figure:modelViewsAndModules}, and similarly to the Scenario and the View entities, it has a ``name'' attribute, which provides identification and also gives an idea on what are the Module functions, and a ``text'' attribute, which corresponds to text added to the template.

As seen in the abstract domain model present in Figure \ref{figure:abstractDomainModel} of Chapter \ref{chapter:domainModel}, the elements of a view have a certain type of relationship with each others. There are eight types of relationships between Modules \cite{clements2003documenting}:
\begin{itemize}
\item \textit{Is-Part-Of} - a Module can be part of a parent Module; 
\item \textit{Uses} - a Module depends on the correct functioning of other Modules to satisfy its own requirements;
\item \textit{Is-A} - a relation of generalization, in which a Module is a generalization, or parent, of other modules; 
\item \textit{Crosscuts} - an Aspect Module, which implements a crosscutting concern of the system, is bound to a Module that is affected by that crosscutting concern;
\item \textit{One-To-One, One-To-Many, Many-to-Many} - logical associations between Data Entity Modules, similar to the UML associations;
\item \textit{Aggregation} - an aggregation relation;
\end{itemize}

Although the abstract domain model in Figure \ref{figure:abstractDomainModel} contains an entity ``Relation'' to represent how the view elements are connected, in the case of the Modules, these relations have no other information than the Modules connected. Therefore, in the implemented model, there are no entities representing the relationships between modules. Instead, there were defined different associations of the Module entity to itself, in order to represent the different relations.

\subsubsection{Is-Part-Of}

The \textit{Is-Part-Of} relation specifies that a Module can be a Sub-Module of one and only one other Module. Figure \ref{figure:modelIsPartOfRelation} shows how this relation was implemented.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small parent};
\draw [umlcd style] (0.5,-2.2) node {\small 0..1};
\draw [umlcd style] (2.060,-0.5) node {\small child};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Is-Part-Of relation between Modules in the implemented model}
\label{figure:modelIsPartOfRelation}
\end{figure}

\subsubsection{Uses}

The \textit{Uses} relation specifies that a Module can depend on the correct functioning of one or more Modules, and one or more Modules can depend on the correct functioning of this Module. Figure \ref{figure:modelUsesRelation} shows how this relation was implemented.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small uses};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.2,-0.5) node {\small usedBy};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Uses relation between Modules in the implemented model}

\label{figure:modelUsesRelation}
\end{figure}

\subsubsection{Is-A}

The \textit{Is-A} relation specifies that a Module can be a specialization of a more general Module. Figure \ref{figure:modelIsARelation} shows how this relation was implemented. There are no restrictions on multiple inheritance in this relation, so a Module can be a specialization of more than one Module. 

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small isA};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.6,-0.5) node {\small superModule};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Uses relation between Modules in the implemented model}
\label{figure:modelIsARelation}
\end{figure}

\subsubsection{Crosscuts}

The \textit{Crosscut} relation specifies that an Aspects Module, which implements a crosscutting concern of the system, can be associated with Modules that are affected with that crosscutting concern. Figure \ref{figure:modelCrosscutsRelation} shows how this relation was implemented in the model.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small crosscuts};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.7,-0.5) node {\small crosscuttedBy};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Uses relation between Modules in the implemented model}
\label{figure:modelCrosscutsRelation}
\end{figure}

\subsubsection{One-To-One, One-To-Many, Many-to-Many}

The \textit{One-To-One, One-To-Many} and \textit{Many-to-Many} relation specify logical associations between Data Entity Modules, similar to UML associations. Figures \ref{figure:modelOneToOneRelation}, \ref{figure:modelOneToManyRelation} and \ref{figure:modelManyToManyRelation} show how these relations were implemented in the model.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small oneToOne};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.7,-0.5) node {\small oneRelation};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{One-To-One relation between Modules in the implemented model}
\label{figure:modelOneToOneRelation}
\end{figure}
\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small oneToMany};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (3.15,-0.5) node {\small oneToManyRelation};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{One-To-Many relation between Modules in the implemented model}
\label{figure:modelOneToManyRelation}
\end{figure}
\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small manyToMany};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (3.25,-0.5) node {\small manyToManyRelation};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Many-To-Many relation between Modules in the implemented model}
\label{figure:modelManyToManyRelation}
\end{figure}

\textbf{To note:} the '*' cardinality in these relations means that a Module can have several relations of this type in a Data Model Style view. For example, if a Module instance with name ``Department'' has a ``One-To-Many'' relation with Modules ``Employee'' and ``Room'', it means that a visual representation of these Modules would be the one in figure \ref{figure:modelOneToManyExample}.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=2.5cm ]{Department}{0,0}
	\attribute {}
\end{class}

\begin{class}[text width=2cm ]{Room}{-2.5,-3}
	\attribute {}
\end{class}

\begin{class}[text width=2cm ]{Employee}{2.5,-3}
	\attribute {}
\end{class}

\association{Department}{}{1}{Room}{}{*}
\association{Department}{}{1}{Employee}{}{*}
\end{tikzpicture}
\caption{Example of the One-To-Many relation between Modules}
\label{figure:modelOneToManyExample}
\end{figure}

\subsubsection{Aggregation}

The \textit{Aggregation} relation specifies that a Module can be an aggregator of other Modules. Figure \ref{figure:modelAggregationRelation} shows how this relation is implemented in the system.

\begin{figure}[h]
\centering
\renewcommand {\umltextcolor}{black}
\renewcommand {\umlfillcolor}{none}
\renewcommand {\umldrawcolor}{black}
\begin{tikzpicture}

\begin{class}[text width=3cm ]{Module}{0,0}
	\attribute { name : String }
	\attribute { identifier : String }
	\attribute { text : String }
\end{class}
	
\draw [umlcd style] (Module.south) -- (0,-2.5) -- (2.5,-2.5) -- (2.5,-1) -- (1.61,-1);
\draw [umlcd style] (-1,-2.2) node {\small aggregator};
\draw [umlcd style] (0.5,-2.2) node {\small 0..*};
\draw [umlcd style] (2.45,-0.5) node {\small aggregated};
\draw [umlcd style] (2.060, -1.4) node {\small 0..*};
\end{tikzpicture}
\caption{Aggregation relation between Modules in the implemented model}
\label{figure:modelAggregationRelation}
\end{figure}

\section{Controller}

This section describes the Controller part of the implemented system. The application developed uses the Spring\footnote{https://spring.io/} Framework, which allows the definition of one or more Java classes to act as Controllers and handle requests.

A Java class is set to be a Controller by annotating it with the \textit{@Controller} annotation, or \textit{@RestController} if the controller's goal is to provide a REST API. Figure \ref{figure:springController} shows an example of a Controller class that handles requests for the url \textit{'/home'} and returns a template that will update the view.

\begin{figure}[h]
\lstset{style=customjava}
\begin{lstlisting}
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class MyController {

	@RequestMapping(value="/home")
	public String home() {
		return "home";
	}
}
\end{lstlisting}
\caption{Example of a Controller class defined using the Spring Framework} 
\label{figure:springController}
\end{figure}

\subsection{Annotation Controller}
The Annotation Controller provides a way to manage the annotations added to a document. It communicates with the Domain Model to create, remove or update Annotations. This controller is in fact a RestController, which means it provides a REST API, used to retrieve a JSON representation of the annotations stored in the model and display it along with the document text. 
The endpoints provided by this controller are described in Table \ref{table:endpoints}.

\begin{table}[h]
\begin{tabular}{ | l | l | l |p{7.7cm}|}
    \hline
    Name & Method & Endpoint & Description \\ \hline
    Index & GET & ../store/annotations & \parbox[t]{8cm}{Returns the set of annotations associated with a \\specific document }\\ \hline
    Read & GET & ../store/annotations/id & Returns the annotation with the specific id \\ \hline
    Create & POST & ../store/annotations & \parbox[t]{8cm}{Creates a new annotation, stores it in the model, \\and redirects to the Read endpoint} \\ \hline
    Update & PUT & ../store/annotations/id & \parbox[t]{8cm}{Updates the annotation with the given id and \\redirects to the Read endpoint} \\ \hline
    Delete & DELETE & ../store/annotations/id & \parbox[t]{8cm}{Removes the annotation with the given id. The \\response is a HTTP/1.0 204 NO CONTENT.} \\ \hline
  \end{tabular}
  \caption{REST API provided by the Annotation Controller}
  \label{table:endpoints}
\end{table}

The ``INDEX'' endpoint has the particularity of iterating through all the Annotations in the system. If the annotation is associated to another domain entity besides the Document (for example, a Scenario, or a Module), information about the domain entity will be added to the annotation body, and will be shown in the interface. This way, it is possible to have some information about the domain entity even before checking its template.

\subsection{Document Controller}
The Document Controller handles the requests to view, add or remove a document from the system.

Adding and removing documents from the system is a feature that only Teachers are authorized to use. The controller receives a POST request containing the URL to the article. The Java library JSoup\footnote{http://jsoup.org/} extracts the HTML from the given URL and the controller processes it and stores a Document in the database. Processing of the extracted HTML includes turning relative URLs into absolute ones for href and src attributes.
The Controller will also check if the database already contains a document with the given URL before adding a new entry. 

When a teacher removes a Document from the system, all Annotations, Scenarios, Modules and Views associated with that Document are removed from the system as well.

Upon Document visualization, there are three other operations handled by this controller:
\begin{itemize}
\item When a user wants to associate an Annotation with a domain entity such as a Scenario, a request is sent to the Document Controller containing information about the annotation unique ID and its tag. Based on the tag, the controller then redirects to another controller, which will provide means for the user to add and/or select an entity to associate with the annotation.

\item When visualizing the Annotation information in the document, it is possible to navigate to the template of the entity to which this annotation is associated by clicking in a link. A request is then sent to the Document Controller, which again checks the Annotation tag, and redirects to the correct Controller.

\item The Document interface also allows the user to navigate to the structured representation of the document, which is an aggregation of all the templates of all the entities added to the system. When the link to navigate to the structured representation is clicked, a request is sent to the Controller, which retrieves information about Scenarios, Views and Elements to be presented to the user.  
\end{itemize}

 
\subsection{Scenario Controller}

The Scenario Controller provides means to add and remove Scenarios from the document and link or unlink annotations from a Scenario or its elements.

A Scenario is created when a user wants to link an Annotation to a Scenario and is prompted the interface to add a new or choose an existing one. When the Controller receives the request to add a new Scenario, it does not only adds a new Scenario to the database, but also adds a new SrcOfStimulus, Stimulus, Artifact, Environment, Response and ResponseMeasure to the databse, all associated with the newly created Scenario. 

When the user chooses which Scenario to link the Annotation with, the Controller receives a request containing both the unique ID of the Scenario and the unique ID of the Annotation. With these IDs, it can verify the tag associated with the Annotation, and add the Annotation either to the Scenario or to the corresponding element. For example, if the tag associated with the Annotation is ``Source Of Stimulus'', then it will be linked to the ``SrcOfStimulus'' instance that is associated with the Scenario with the specified ID.

A Scenario is initially created without any tactics. These are added in the Scenario Template, and their creation is handled by the Scenario Controller. Upon receiving the corresponding request, a new ``Tactic'' is added to the database containing the tactic's name, and is associated with the corresponding Scenario. When an Annotation with the tag ``Tactic'' is added to a Scenario, it is associated with the ``Scenario'' entity. Inside the template, these annotations can be associated with the added tactics, and this change is also handled by the Scenario Controller. 

When user text is added to a Scenario or one of its elements, a request is sent to this Controller. It will then update the Model accordingly and show the updated Model in the corresponding View.

\subsection{Module Controller}

Similarly to the Scenario Controller, the Module Controller handles the creation and deletion of Modules, which are the elements of Module Viewtype Views. It also handles the linkage of Annotations to existent Modules and the addition of user text to a Module.

As explained in Chapter \ref{chapter:domainModel}, the Elements of a View are related to each others, and in Section \ref{section:model}, we can see that, since the relations between Modules have no information other than the Modules involved, they are implemented as different associations of the ``Module'' entity to itself. The Module Controller handles adding and removing other Modules to/from the possible relations. The requests are unique for each relation, meaning the request to add a Module to the \textit{Uses} relation of a certain Module will be in the form \textit{/setModuleUses/...} and the request to add \textit{One-To-One} relations with other Modules to a certain Module will be in the form \textit{/setModuleOneToOne/...}. Each request modifies the corresponding association accordingly. 

...
 
